In this page, we provide Python implementations of Algorithm 1 and Algorithm 2 
in the paper "Decoding algorithms of monotone codes and azinv codes and their unified view". 
The Python implementations of each error-correcting algorithm are described in Algorithm 1.py and Algorithm 2.py.
The function names used in Algorithm 1.py are the same as those used in Flowchart 1 provided in the paper. 
The function names used in Algorithm 2.py are the same as those used in Flowchart 2 provided in the paper.
Algorithm 1_deletion.py, Algorithm 1_substitution.py, Algorithm 2_BAD.py, and Algorithm 2_BAS.py contain descriptions and examples of the decodeing algorithms.

Furthermore, we provide graphs of the computational cost for Python implementations of each error-correcting algorithm. 
We clarify our implement environment: Python runs over the code editor ''Jupyter notebook'' 
and over a laptop computer with the 2.3GHz dual-core Intel Core i5 CPU, the 4GB of  RAM, and Windows 10 OS.
The size of a problem instance is indicated by the code length.
The graphs report running time results in seconds.
The computational cost graph of Algorithm 1 for deletion error-correcting is in the dec_time_del.py file. The computational cost graph of Algorithm 1 for substitution error-correcting is in the dec_time_sub.py file. The computational cost graph of Algorithm 2 for BAD error-correcting is in the dec_time_BAD.py file. 
The computational cost graph of Algorithm 2 for BAS error-correcting is in the dec_time_BAS.py file.


